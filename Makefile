ifneq (,$(wildcard ./.env))
  include .env
endif

ROOT_DIR := $(CURDIR)
OUT_DIR := $(ROOT_DIR)/out
SCRIPT_DIR := $(ROOT_DIR)/scripts
CONFIG_DIR := $(ROOT_DIR)/config
CLANG_DIR ?= $(ROOT_DIR)/toolchain/clang

CLANG_URL := https://github.com/llvm/llvm-project/releases/download/llvmorg-17.0.6/clang+llvm-17.0.6-x86_64-linux-gnu-ubuntu-22.04.tar.xz

SHARED_DIR := $(ROOT_DIR)/shared

VERBOSE ?= 0

ARCH ?= x86_64

BEAR ?= 0

GREEN := $(shell tput setaf 2)
YELLOW := $(shell tput setaf 3)
NC := $(shell tput sgr0)

ifeq ($(ARCH),aarch64)
  $(warning $(YELLOW)Incorrect architecture 'aarch64', using 'arm64' instead $(NC))
  ARCH := arm64
else ifeq ($(ARCH),x86)
  $(warning $(YELLOW)Incorrect architecture 'x86', using 'x86_64' instead $(NC))
  ARCH := x86_64
else ifeq ($(filter x86_64 arm64 i386,$(ARCH)),)
  $(error Invalid architecture $(ARCH))
endif

ifneq ($(ARCH),arm64)
  # We currently only support Trusty with arm64, as we rely on ARM TF-A
  ifneq ($(filter trusty,$(MAKECMDGOALS)),)
    $(error Building Trusty is only supported on arm64)
  endif
endif


.PHONY: default
default: linux linux_modules tools-vm

.PHONY: clean
clean: linux_clean tools-vm_clean

.PHONY: help
help:
	@echo '$(GREEN)General Environment Variables:$(NC)'
	@echo '   ARCH                             - Specify one of the supported architectures: x86_64, i386, arm64 (default: x86_64)'
	@echo '   ACK                              - Set to 1 to build ACK instead of the Linux kernel. Does not need to be set for `ack` and `run-ack` targets (default: 0)'
	@echo '   VERBOSE                          - Set to 1 to enable verbose output (default: 0)'
	@echo ''
	@echo '$(GREEN)Build/Config:$(NC)'
	@echo '   Targets:'
	@echo '      linux (default)               - Build the Linux kernel'
	@echo '      linux_defconfig               - Run `make defconfig`'
	@echo '      linux_menuconfig              - Run `make menuconfig`'
	@echo '      linux_modules                 - Build the Linux kernel modules'
	@echo '      linux_debpkg                  - Creates a Debian package for the kernel'
	@echo '      ack                           - Build the Android Common Kernel'
	@echo '      tools-vm                      - Build linux/tools/vm'
	@echo ''
	@echo '   Environment Variables:'
	@echo '      LINUX_DEFCONFIG               - The defconfig to use when building the kernel (default: defconfig, ACK default: gki_defconfig)'
	@echo '      LINUX_SRC                     - The path to the kernel source directory (default: linux, ACK default: ack/common)'
	@echo '      LINUX_OUT                     - The path where the kernel build output should be stored (default: out/linux/$$ARCH, ACK default: out/ack/common/$$ARCH)'
	@echo '      LINUX_CONFIG_FRAGMENT         - A kernel config fragment to merge with the defconfig (default: config/config.fragment)'
	@echo ''
	@echo '$(GREEN)Clean:$(NC)'
	@echo '   Targets:'
	@echo '      clean                         - Clean output from default build targets'
	@echo '      <target>_clean                - Clean output for <target>, where <target> is one of: ack, linux, tools-vm, rootfs'
	@echo ''
	@echo '$(GREEN)Run/Debug:$(NC)'
	@echo '   Targets:'
	@echo '      run                           - Run QEMU with the built kernel and rootfs image'
	@echo '      run-ack                       - Same as `run` but runs ACK instead'
	@echo ''
	@echo '   Environment Variables:'
	@echo '      GDB                           - Set to 1 to start a gdbserver and wait for GDB when running QEMU (default: 0)'
	@echo '      CPU                           - The number of CPUs to use when running QEMU (default: 4)'
	@echo '      MEM                           - The memory size in MB to use when running QEMU (default: 1024)'
	@echo '      QEMU_EXTRA_ARGS               - Additional arguments to pass to QEMU (default: "")'
	@echo '      QEMU_EXTRA_KERNEL_CMDLINE     - Additional arguments to pass to the kernel (default: "")'
	@echo '      QEMU_KERNEL_IMAGE             - The path to the kernel image to run (x86_64/i386 default: $$LINUX_OUT/arch/$$ARCH/boot/bzImage, arm64 default: $$LINUX_OUT/arch/$$ARCH/boot/Image)'
	@echo '      ROOTFS                        - The path to the rootfs image file (default: rootfs/alpine-$$ARCH.img)'
	@echo '      ROOTFS_FORMAT                 - The format of the rootfs image file: raw, qcow2 (default: qcow2)'
	@echo '      INITRD                        - Set to 1 to use the $$CPIO_FILE initramfs instead of the $$ROOTFS image as the rootfs, or specify the path to an alternative CPIO file (default: "")'
	@echo '      RDINIT                        - The value of the `rdinit` kernel command line parameter (default: "", default if INITRD is set: /sbin/init)'
	@echo '      ECHR                          - The value of the QEMU `-echr` flag (default: 1)'
	@echo '      ROOT                          - The value of the `root` kernel command line parameter (default: /dev/vda)'
	@echo '      RW                            - Whether to mount the rootfs as read-write or read-only: ro, rw (default: rw)'
	@echo '      KASLR                         - Set to 1 to enable KASLR (default: 0)'
	@echo ''
	@echo '$(GREEN)rootfs:$(NC)'
	@echo '   Targets:'
	@echo '      rootfs-init                   - Extract the Alpine Linux rootfs to $$ROOTFS_DIR and then run the `rootfs-overlay` target'
	@echo '      rootfs-overlay                - Apply arch-specific changes to $$ROOTFS_DIR and run the `rootfs` target'
	@echo '      rootfs                        - Run the `ext4` and `cpio` targets'
	@echo '      ext4                          - Build a $$ROOTFS $$ROOTFS_FORMAT (default qcow2) image with an ext4 filesystem from $$ROOTFS_DIR'
	@echo '      cpio                          - Build a $$CPIO_FILE gzipped initramfs CPIO file from $$ROOTFS_DIR'
	@echo '      initramfs                     - An alias for the `cpio` target'
	@echo '      uncpio                        - Extract $$CPIO_FILE to $$ROOTFS_DIR'
	@echo '      rootfs-mount                  - Mount $$ROOTFS image at /tmp/rootfs'
	@echo '      rootfs-unmount                - Unmount rootfs image from /tmp/rootfs'
	@echo '      chroot                        - chroot into $$ROOTFS_DIR'
	@echo ''
	@echo '   Environment Variables:'
	@echo '      EXT4_SIZE                     - The disk size of the rootfs image to build'
	@echo '      ROOTFS_DIR                    - The directory to create the ext4 rootfs image and initramfs CPIO from (default: rootfs/alpine-$$ARCH)'
	@echo '      ROOTFS                        - The path to the rootfs image file (default: rootfs/alpine-$$ARCH.img)'
	@echo '      ROOTFS_FORMAT                 - The format of the rootfs image file: raw, qcow2 (default: qcow2)'
	@echo '      CPIO_FILE                     - The path to the CPIO file to create (default: rootfs/alpine-$$ARCH.cpio.gz)'
	@echo ''
	@echo '$(GREEN)Miscellaneous:$(NC)'
	@echo '   Targets:'
	@echo '      linux_download                - Downloads an archive of the Linux kernel source for the version specified in $$VERSION'
	@echo '      linux_checkout                - Checks out the version specified by $$VERSION of the linux kernel in $$LINUX_SRC'
	@echo ''
	@echo '   Environment Variables:'
	@echo "      VERSION                       - The version to download or checkout. For checkout only, if the third number in the version string is a 'y', the latest version of the kernel with that major and minor version is used. Examples: 5.10, 5.10.107, v5.10, 5.10.y, linux-5.10.y"

$(SHARED_DIR):
	mkdir -p $(SHARED_DIR)

##
## Linux Kernel and Android Common Kernel
##

ACK_TARGETS := ack ack_clean run-ack
ACK ?= 0

ACK_SRC := $(ROOT_DIR)/ack/common
ACK_OUT := $(OUT_DIR)/ack/common/$(ARCH)

ifneq ($(filter $(ACK_TARGETS),$(MAKECMDGOALS)),)
  ACK := 1
endif

# If we're building ACK instead of Linux, set the appropriate variables
ifeq ($(ACK),1)
  LINUX_SRC ?= $(ACK_SRC)
  LINUX_OUT ?= $(ACK_OUT)
  LINUX_DEFCONFIG ?= gki_defconfig
else
  LINUX_SRC ?= $(ROOT_DIR)/linux
  LINUX_OUT ?= $(OUT_DIR)/linux/$(ARCH)
  LINUX_DEFCONFIG ?= defconfig
endif

TRUSTY_LINUX_CONFIG_FRAGMENT := $(ROOT_DIR)/trusty/external/linux/arch/arm64/configs/trusty_qemu_defconfig.fragment

LINUX_CONFIG_FRAGMENT ?= $(CONFIG_DIR)/config.fragment
LINUX_OUT_MODULES_DEP := $(LINUX_OUT)/modules_install.stamp
LINUX_MODULES_INSTALL_PATH := $(LINUX_OUT)/modules_install
LINUX_CONFIG := $(LINUX_OUT)/.config

ifeq ($(ARCH),x86_64)
  TARGET := x86_64-pc-linux-gnu
  KERNEL_IMAGE := $(LINUX_OUT)/arch/$(ARCH)/boot/bzImage
else ifeq ($(ARCH),i386)
  TARGET := i386-pc-linux-gnu
  KERNEL_IMAGE := $(LINUX_OUT)/arch/$(ARCH)/boot/bzImage
else ifeq ($(ARCH),arm64)
  TARGET := aarch64-linux-gnu
  KERNEL_IMAGE := $(LINUX_OUT)/arch/$(ARCH)/boot/Image
endif

LINUX_MAKE := \
  PATH=$(CLANG_DIR)/bin:$(PATH) \
  $(MAKE) \
  -C $(LINUX_SRC) \
  ARCH=$(ARCH) \
  CROSS_COMPILE=$(TARGET)- \
  LLVM=1 LLVM_IAS=1 \
  V=$(VERBOSE) \
  O=$(LINUX_OUT) \
  -j `nproc`

$(CLANG_DIR):
	$(warning $(YELLOW)Clang directory $(CLANG_DIR) does not exist, downloading prebuilt binaries $(NC))
	wget --no-verbose --show-progress $(CLANG_URL) -O clang.tar.xz
	mkdir -p $(CLANG_DIR)
	tar -xf clang.tar.xz -C $(CLANG_DIR) --strip-components=1

.PHONY: linux_defconfig
linux_defconfig $(LINUX_CONFIG): $(LINUX_CONFIG_FRAGMENT) | $(CLANG_DIR)
	+ $(LINUX_MAKE) $(LINUX_DEFCONFIG)
	KCONFIG_CONFIG=$(LINUX_CONFIG) \
		$(LINUX_SRC)/scripts/kconfig/merge_config.sh \
		-m \
		$(LINUX_CONFIG) \
		$(LINUX_CONFIG_FRAGMENT)
	+ $(LINUX_MAKE) olddefconfig
	$(SCRIPT_DIR)/check_merged_config.sh $(LINUX_CONFIG) $(LINUX_CONFIG_FRAGMENT)

.PHONY: linux_menuconfig
linux_menuconfig:
	+ $(LINUX_MAKE) menuconfig
	$(SCRIPT_DIR)/check_merged_config.sh $(LINUX_CONFIG) $(LINUX_CONFIG_FRAGMENT)

.PHONY: linux
linux $(KERNEL_IMAGE): $(LINUX_CONFIG) | $(CLANG_DIR)
	+ $(LINUX_MAKE)
# Older versions of Linux don't have this script
ifneq (,$(wildcard $(LINUX_SRC)/scripts/clang-tools/gen_compile_commands.py))
	cd $(LINUX_SRC) && ./scripts/clang-tools/gen_compile_commands.py -d $(LINUX_OUT)
endif


.PHONY: linux_modules
linux_modules $(LINUX_OUT_MODULES_DEP): $(KERNEL_IMAGE)
	+ $(LINUX_MAKE) modules
	+ $(LINUX_MAKE) INSTALL_MOD_PATH=$(LINUX_MODULES_INSTALL_PATH) modules_install
	@find $(LINUX_MODULES_INSTALL_PATH) -type f | sort | \
		xargs sha1sum > $(LINUX_OUT_MODULES_DEP).tmp
	@cmp $(LINUX_OUT_MODULES_DEP).tmp $(LINUX_OUT_MODULES_DEP) || \
		mv $(LINUX_OUT_MODULES_DEP).tmp $(LINUX_OUT_MODULES_DEP)

.PHONY: linux_clean
linux_clean:
	+ $(LINUX_MAKE) mrproper

.PHONY: linux_download
linux_download:
ifndef VERSION
	$(error VERSION environment variable is not defined)
endif
	$(SCRIPT_DIR)/download_linux.sh $(VERSION) $(ACK)

.PHONY: linux_checkout
linux_checkout:
ifndef VERSION
	$(error VERSION environment variable is not defined)
endif
	$(SCRIPT_DIR)/checkout_linux.sh $(VERSION) $(LINUX_SRC)

# Use xz compression instead of zstd, as the latter is not supported by some
# versions of dpkg.
.PHONY: linux_debpkg
linux_debpkg: $(KERNEL_IMAGE)
	+ $(LINUX_MAKE) KDEB_COMPRESS=xz bindeb-pkg


# These targets do the same thing as the `linux` targets, but because they're in
# `ACK_TARGETS`, the `ACK` variable is set to 1 and the ACK source and output
# directories are used instead of the Linux directories. The same thing can be
# achieved by setting the `ACK=1` environment variable, so these are just
# provided for convenience.
.PHONY: ack
ack: linux

.PHONY: ack_clean
ack_clean: linux_clean

# Because of how `tools/vm/Makefile` is designed, we can't use `$(LINUX_MAKE)`
# here, as specifying the `O` variable causes compilation errors, and `clang`
# won't properly cross-compile the binary so we need to use GCC
TOOLS_MAKE := $(MAKE) \
  -C $(LINUX_SRC)/tools \
  DESTDIR=$(SHARED_DIR) \
  sbindir=/tools/$(ARCH)

# Assuming we're building on an x86 system, we should only set `CROSS_COMPILE`
# if we're building arm64.
ifeq ($(ARCH),arm64)
  TOOLS_MAKE += CROSS_COMPILE=$(TARGET)-
endif

.PHONY: tools-vm
tools-vm: | $(SHARED_DIR)
	+ $(TOOLS_MAKE) vm_install

.PHONY: tools-vm_clean
tools-vm_clean:
	+ $(TOOLS_MAKE) vm_clean
	rm -f $(SHARED_DIR)/tools/$(ARCH)/{page_owner_sort,page-types,slabinfo}

##
## Generate rootfs images
##

ROOTFS_PARENT_DIR := $(ROOT_DIR)/rootfs
ROOTFS ?= $(ROOTFS_PARENT_DIR)/$$(basename $(ROOTFS_DIR)).img
ROOTFS_FORMAT ?= qcow2
ROOTFS_DIR ?= $(ROOTFS_PARENT_DIR)/alpine-$(ARCH)
CPIO_FILE ?= $(ROOTFS_PARENT_DIR)/$$(basename $(ROOTFS_DIR)).cpio.gz
EXT4_SIZE ?= 1G
ifeq ($(SUDO),1)
	SUDO := sudo
endif

# The user might set a relative path for `CPIO_FILE`, so we need to get the
# absolute path, as we need to reference it after we've changed directories
CPIO_FILE := $(shell realpath $(CPIO_FILE))

$(ROOTFS_DIR):
	mkdir -p $(ROOTFS_DIR)

.PHONY: rootfs-init
rootfs-init: | $(ROOTFS_DIR)
	tar -xf $(ROOTFS_PARENT_DIR)/alpine-minirootfs-*-$(ARCH).tar.gz -C $(ROOTFS_DIR)
	$(MAKE) rootfs-overlay

.PHONY: rootfs-overlay
rootfs-overlay: | $(ROOTFS_DIR)
	$(SUDO) cp -f -r $(CONFIG_DIR)/rootfs-overlay/. $(ROOTFS_DIR)
	$(SUDO) $(SCRIPT_DIR)/arch_specific.sh $(ARCH) $(ROOTFS_DIR)
	$(MAKE) rootfs

.PHONY: ext4
ext4: | $(ROOTFS_DIR)
	dd if=/dev/zero of=$(ROOTFS) bs=1 count=0 seek=$(EXT4_SIZE)
	$(SUDO) mkfs.ext4 -b 4096 -d $(ROOTFS_DIR) -F $(ROOTFS)
	qemu-img convert -O $(ROOTFS_FORMAT) $(ROOTFS) $(ROOTFS).tmp
	mv $(ROOTFS).tmp $(ROOTFS)

.PHONY: cpio initramfs
initramfs cpio: | $(ROOTFS_DIR)
	(cd $(ROOTFS_DIR) && $(SUDO) find . -print0 \
		| $(SUDO) cpio --null --create --verbose --format=newc) \
		| gzip --best > $(CPIO_FILE)

.PHONY: uncpio
uncpio: | $(ROOTFS_DIR)
	cd $(ROOTFS_DIR) && zcat $(CPIO_FILE) | $(SUDO) cpio --extract --make-directories --format=newc --no-absolute-filenames

.PHONY: rootfs
rootfs: ext4 cpio

.PHONY: rootfs-mount
rootfs-mount:
	sudo modprobe nbd
	sudo qemu-nbd -c /dev/nbd0 -f $(ROOTFS_FORMAT) $(ROOTFS)
	mkdir -p /tmp/rootfs
	sudo mount /dev/nbd0 /tmp/rootfs

.PHONY: rootfs-unmount
rootfs-unmount:
	sudo umount /dev/nbd0
	sudo qemu-nbd -d /dev/nbd0

.PHONY: chroot
chroot:
	sudo chroot $(ROOTFS_DIR) /bin/sh

.PHONY: rootfs_clean
rootfs_clean:
	$(SUDO) rm -rf $(ROOTFS_DIR)
	$(SUDO) rm -f $(CPIO_FILE)
	$(SUDO) rm -f $(ROOTFS)

##
## U-Boot
##

# Note: We're reusing the TARGET variable from the Linux build section

UBOOT_SRC ?= $(ROOT_DIR)/u-boot
UBOOT_OUT ?= $(OUT_DIR)/uboot/$(ARCH)
UBOOT_CONFIG := $(UBOOT_OUT)/.config
UBOOT_BIN := $(UBOOT_OUT)/u-boot.bin

ifeq ($(ARCH),x86_64)
  UBOOT_DEFCONFIG ?= qemu-x86_64_defconfig
else ifeq ($(ARCH),i386)
  UBOOT_DEFCONFIG ?= qemu-x86_defconfig
else ifeq ($(ARCH),arm64)
  UBOOT_DEFCONFIG ?= qemu_arm64_defconfig
endif

UBOOT_MAKE := \
	PATH=$(CLANG_DIR)/bin:$(PATH) \
	$(MAKE) \
	-C $(UBOOT_SRC) \
	HOSTCC=clang \
	O=$(UBOOT_OUT) \
	-j `nproc`

.PHONY: uboot_defconfig
uboot_defconfig $(UBOOT_CONFIG): | $(CLANG_DIR)
	+ $(UBOOT_MAKE) $(UBOOT_DEFCONFIG)

.PHONY: uboot
uboot $(UBOOT_BIN): $(UBOOT_CONFIG) | $(CLANG_DIR)
	+ $(UBOOT_MAKE) CROSS_COMPILE=$(TARGET)- CC=clang
	cd $(UBOOT_SRC) && ./scripts/gen_compile_commands.py -d $(UBOOT_OUT)

.PHONY: uboot_clean
uboot_clean:
	+ $(UBOOT_MAKE) mrproper

##
## Trusty
##

TRUSTY_SRC ?= $(ROOT_DIR)/trusty
TRUSTY_TARGET ?= qemu-generic-arm64-test-debug
TRUSTY_BUILD_ROOT ?= $(OUT_DIR)/trusty
TRUSTY_OUT := $(TRUSTY_BUILD_ROOT)/build-$(TRUSTY_TARGET)
TRUSTY_KERNEL_IMAGE := $(TRUSTY_OUT)/linux-build/arch/arm64/boot/Image

QEMU_BRANCH := stable-7.2

ATF_DIR := $(TRUSTY_OUT)/atf/qemu/debug
ATF_BL1 := $(ATF_DIR)/bl1.bin
ATF_BL33 := $(ATF_DIR)/bl33.bin

BEAR_CMD :=
ifeq ($(BEAR),1)
  BEAR_CMD := bear --output $(TRUSTY_SRC) --
endif

# Trusty is not a submodule, we need to sync it manually
$(TRUSTY_SRC):
	mkdir -p $(TRUSTY_SRC)

.PHONY: trusty-init
trusty-init: | $(TRUSTY_SRC)
	cd $(TRUSTY_SRC) && repo init -u https://android.googlesource.com/trusty/manifest -b main
	cd $(TRUSTY_SRC) && repo sync -j`nproc` -c --no-tags

	$(MAKE) trusty-qemu-init

# QEMU 3.0 is used by trusty by default. Let's use something newer, we just
# need to apply some Android-specific patches:
#   a4d024b2 arm_gic: Implement GICC_AIAR, GICC_AEOIR and GICC_AHPPIR
#   f0600685 Fix GIC model for aliased interrupts
#   8a933fbb hw/virt/arm: double the amount of secure memory
#   0bfea659 hw/arm/virt: Commandeer most of PCIE_MMIO region for secure memory
.PHONY: trusty-qemu-init
trusty-qemu-init:
	- cd $(TRUSTY_SRC)/external/qemu \
		&& git remote add upstream https://gitlab.com/qemu-project/qemu.git

	cd $(TRUSTY_SRC)/external/qemu \
		&& git fetch upstream $(QEMU_BRANCH) \
		&& git checkout upstream/$(QEMU_BRANCH) \
		&& git cherry-pick a4d024b2fdcc478402d00890965eeacb5542c12e \
		&& git cherry-pick f060068503259b661be8bd8c803291ff6412d2d6 \
		&& git cherry-pick 8a933fbb9c6fb8add1c74f5b523ecb44da7372fa \
		&& git cherry-pick 0bfea6599b8a3ebd2c3f98bf6e0d2705e5cb609c

	sed -i 's|include project/qemu-qemu-inc.mk|include $(CONFIG_DIR)/trusty/qemu-qemu-inc.mk|g' $(TRUSTY_SRC)/trusty/device/arm/generic-arm64/project/qemu-inc.mk

.PHONY: trusty
trusty $(ATF_BL1) $(TRUSTY_KERNEL_IMAGE): | $(TRUSTY_SRC)
	$(BEAR_CMD) $(TRUSTY_SRC)/trusty/vendor/google/aosp/scripts/build.py \
		--build-root $(TRUSTY_BUILD_ROOT) \
		--skip-tests $(TRUSTY_TARGET)
	$(MAKE) trusty-bl33

.PHONY: trusty-bl33
trusty-bl33 $(ATF_BL33): $(UBOOT_BIN)
	rm $(ATF_BL33)
	cp $(UBOOT_BIN) $(ATF_BL33)

.PHONY: trusty_clean
trusty_clean:
	rm -rf $(TRUSTY_OUT)

# When Trusty is enabled, use the kernel image built by Trusty
ifeq ($(TRUSTY),1)
  ifeq ($(ACK),1)
    ifndef QEMU_KERNEL_IMAGE
      $(warning $(YELLOW)ACK was enabled, but Trusty runs with its own kernel. To force using a specific kernel image, add `QEMU_KERNEL_IMAGE=$(KERNEL_IMAGE)` to the command line $(NC))
    endif
  endif

  KERNEL_IMAGE := $(TRUSTY_KERNEL_IMAGE)
endif

##
## Android
##

# TODO: We shouldn't depend on Trusty for this
TRUSTY_PREBUILT_IMAGE_DIR := $(TRUSTY_SRC)/trusty/prebuilts/aosp/android/out/target/product/trusty/
SYSTEM_IMG := $(TRUSTY_PREBUILT_IMAGE_DIR)/system.img
VENDOR_IMG := $(TRUSTY_PREBUILT_IMAGE_DIR)/vendor.img
USERDATA_IMG := $(TRUSTY_PREBUILT_IMAGE_DIR)/userdata.img

ANDROID_USERSPACE ?= 0

DTC := dtc

ANDROID_DTS := $(OUT_DIR)/android.dts
ANDROID_DTB := $(OUT_DIR)/android.dtb
QEMU_DTB := $(OUT_DIR)/qemu.dtb
QEMU_DTS := $(OUT_DIR)/qemu.dts

.PHONY: android-dtb
android-dtb $(ANDROID_DTB):
ifneq ($(ARCH),arm64)
    $(error android-dtb is only supported from arm64)
endif

	QEMU_EXTRA_ARGS="-M dumpdtb=$(QEMU_DTB)" $(MAKE) run
	$(DTC) -I dtb -O dts $(QEMU_DTB) > $(QEMU_DTS)
	cat $(QEMU_DTS) $(ATF_DIR)/firmware.android.dts > $(ANDROID_DTS)
	$(DTC) -I dts -O dtb $(ANDROID_DTS) > $(ANDROID_DTB)

##
## Run QEMU
##

CPU ?= 4
MEM ?= 1024
QEMU_EXTRA_ARGS ?=
QEMU_EXTRA_KERNEL_CMDLINE ?=
GDB ?= 0
INITRD ?=
RDINIT ?= /sbin/init
QEMU_KERNEL_IMAGE ?= $(KERNEL_IMAGE)
ECHR ?= 1
ROOT ?= /dev/vda
RW ?= rw
KASLR ?= 0

UBOOT ?= 0
TRUSTY ?= 0

ifeq ($(ANDROID_USERSPACE),1)
  SELINUX ?= 1
else
  SELINUX ?= 0
endif

QEMU_KERNEL_CMDLINE := selinux=$(SELINUX)

QEMU_ARGS := \
  -m $(MEM) \
  -smp $(CPU) \
  -nographic \
  -no-reboot \
  -kernel $(QEMU_KERNEL_IMAGE) \
  -echr $(ECHR) \
  $(QEMU_EXTRA_ARGS)

ifneq ($(TRUSTY),1)
  QEMU_ARGS += -netdev user,id=eth0,hostfwd=tcp::7777-:7777,hostfwd=tcp::2222-:22,hostfwd=tcp::2223-:23 -device virtio-net-pci,netdev=eth0
  QEMU_ARGS += -virtfs local,security_model=mapped-xattr,path=$(SHARED_DIR),mount_tag=shared
  #QEMU_ARGS += -virtfs local,security_model=mapped-xattr,path=$(LINUX_MODULES_INSTALL_PATH)/lib/modules,mount_tag=modules
endif

ifeq ($(TRUSTY),1)
  QEMU_ARGS += -bios $(ATF_BL1)
else ifeq ($(UBOOT),1)
  QEMU_ARGS += -bios $(UBOOT_BIN)
endif

# TODO: check that ROOTFS and ANDROID_USERSPACE aren't both passed at the same time?
ifeq ($(ANDROID_USERSPACE),1)
  QEMU_ARGS += \
    -device virtio-blk,drive=vda -drive file=$(SYSTEM_IMG),index=0,if=none,id=vda,format=raw \
    -device virtio-blk,drive=vdb -drive file=$(VENDOR_IMG),index=1,if=none,id=vdb,format=raw \
    -device virtio-blk,drive=vdc -drive file=$(USERDATA_IMG),index=2,if=none,id=vdc,format=raw \
    -device virtio-net,netdev=adbnet0 -netdev user,id=adbnet0,hostfwd=tcp::5554-:5554,hostfwd=tcp::5555-:5555
  QEMU_KERNEL_CMDLINE += root=$(ROOT) $(RW) kvm-arm.mode=protected earlyprintk androidboot.hardware=qemu_trusty trusty-log.log_ratelimit_interval=0 trusty-log.log_to_dmesg=always
  QEMU_ARGS += -dtb $(ANDROID_DTB)
else ifneq ($(INITRD),)
  ifeq ($(INITRD),1)
    INITRD := $(CPIO_FILE)
  endif
  QEMU_KERNEL_CMDLINE += rdinit=$(RDINIT)
  QEMU_ARGS += -initrd $(INITRD)
else
  QEMU_ARGS += -drive file=$(ROOTFS),if=virtio,format=$(ROOTFS_FORMAT)
  QEMU_KERNEL_CMDLINE += root=$(ROOT) $(RW)
endif

ifeq ($(GDB),1)
  QEMU_ARGS += -s -S
endif

ifeq ($(ARCH),x86_64)
  QEMU_BIN ?= qemu-system-x86_64
  QEMU_KERNEL_CMDLINE += console=ttyS0 kpti no5lvl

  QEMU_ARGS += -cpu kvm64,+smep,+smap

  # We can't use KVM with GitHub Actions CI
  ifneq ($(CI),true)
    QEMU_ARGS += -accel kvm
  endif
else ifeq ($(ARCH),i386)
  QEMU_BIN ?= qemu-system-i386
  QEMU_KERNEL_CMDLINE += console=ttyS0
else
  ifeq ($(TRUSTY),1)
    # Trusty needs to use its own build of QEMU which has some custom patches
    QEMU_BIN ?= $(TRUSTY_OUT)/qemu-build/aarch64-softmmu/qemu-system-aarch64
  else
    QEMU_BIN ?= qemu-system-aarch64
  endif

  QEMU_KERNEL_CMDLINE += console=ttyAMA0

  ifeq ($(TRUSTY),1)
    MACHINE := -machine virt,secure=on,virtualization=on
  else
    MACHINE := -machine virt,virtualization=on
  endif

  QEMU_ARGS += \
    $(MACHINE) \
    -cpu cortex-a53 \
    -semihosting-config enable=on,target=native
endif

ifeq ($(KASLR),0)
  QEMU_KERNEL_CMDLINE += nokaslr
endif

QEMU_ARGS += -append "$(QEMU_KERNEL_CMDLINE) $(QEMU_EXTRA_KERNEL_CMDLINE)"

RUN_DEPS := $(QEMU_KERNEL_IMAGE)
RUN_DIR := $(ROOT_DIR)

ifeq ($(UBOOT),1)
  RUN_DEPS += $(UBOOT_BIN)
endif

ifeq ($(TRUSTY),1)
  RUN_DEPS += $(ATF_BL1)
  # TODO: Is there a QEMU flag we can use to make this not necessary?
  RUN_DIR := $(ATF_DIR)
endif

ifeq ($(ANDROID_USERSPACE),1)
  # We need this device tree blob to mount /vendor
  RUN_DEPS += $(ANDROID_DTB)
endif

.PHONY: run
run: $(RUN_DEPS) | $(SHARED_DIR)
	@echo "$(GREEN)Running QEMU, press 'ctrl-a x' to quit $(NC)"
ifeq ($(GDB),1)
	@echo "$(ARCH) $(ACK) $(TRUSTY) $(TRUSTY_TARGET)" > $(OUT_DIR)/.gdb
	@echo "$(GREEN)Waiting for GDB, attach with \`scripts/gdb.sh\` $(NC)"

ifdef TERMINAL_CMD
	$(TERMINAL_CMD) $(SCRIPT_DIR)/gdb.sh
endif

endif
	@echo ''
	cd $(RUN_DIR) && $(QEMU_BIN) $(QEMU_ARGS)

.PHONY: run-ack
run-ack: run
